[Вопросы для собеседования](README.md)

# Протокол передачи данных

+ [Модель OSI](#Модель-OSI)
+ [Модель TCP IP](#Модель-TCP-IP)
+ [Разница между моделью TCP IP и моделью OSI](#Разница-между-моделью-TCP-IP-и-моделью-OSI)
+ [HTTP](#HTTP)
+ [Структура HTTP запроса](#Структура-HTTP-запроса)
+ [Все версии HTTP](#Все-версии-HTTP)
+ [Ключевые различия между версиями HTTP](#Ключевые-различия-между-версиями-HTTP)
+ [HTTPS](#HTTPS)
+ [TLS SSL](#TLS-SSL)
+ [Установка соединения TLS](#Установка-соединения-TLS)

# Модель OSI

`Модель OSI (Open Systems Interconnection)` — это концептуальная модель, разработанная Международной организацией по стандартизации (ISO), которая служит для стандартизации функций связи и взаимодействия между различными системами связи и сетями. Модель OSI состоит из семи уровней, каждый из которых выполняет определенные функции и взаимодействует с уровнями выше и ниже.

## Рассмотрим каждый уровень модели OSI подробно:

1. `Физический уровень (Physical Layer)`

**Основные функции:**

- Определяет физические характеристики сети, такие как тип кабеля, разъемы, электрические сигналы, частоты и т.д.
- Отвечает за физическое соединение между устройствами.
- `Примеры технологий:` Ethernet, USB, Bluetooth, Wi-Fi.

2. `Канальный уровень (Data Link Layer)`

**Основные функции:**

- Обеспечивает надежную передачу данных между двумя узлами, подключенными к одному и тому же физическому каналу.
- Управляет доступом к среде передачи, обрабатывает ошибки, выполняет адресацию на уровне кадров.
- `Примеры технологий:` Ethernet (IEEE 802.3), PPP, HDLC, MAC-адреса.

3.` Сетевой уровень (Network Layer)`

**Основные функции:**

- Отвечает за маршрутизацию пакетов данных между узлами в сети.
- Управляет логической адресацией, фрагментацией и сборкой пакетов.
- `Примеры технологий:` IP (Internet Protocol), ICMP, ARP, IP-адреса.

4. `Транспортный уровень (Transport Layer)`

**Основные функции:**

- Обеспечивает надежную передачу данных между узлами.
- Управляет сегментацией данных, контролем потока и исправлением ошибок.
- `Примеры технологий:` TCP (Transmission Control Protocol), UDP (User Datagram Protocol).

5. `Сеансовый уровень (Session Layer)`

**Основные функции:**

- Управляет установлением, поддержанием и завершением сеансов связи между приложениями.
- Синхронизирует данные и обеспечивает управление диалогом.
- `Примеры технологий:` NetBIOS, PPTP, RPC.

6. `Представительский уровень (Presentation Layer)`

**Основные функции:**

- Отвечает за преобразование данных в формат, удобный для приложения.
- Обеспечивает шифрование, дешифрование, сжатие и разжатие данных.
- `Примеры технологий:` JPEG, MPEG, SSL/TLS, ASCII, EBCDIC.

7. `Прикладной уровень (Application Layer)`

**Основные функции:**

- Предоставляет интерфейсы и протоколы для взаимодействия пользователя с приложениями.
- Обеспечивает доступ к сетевым сервисам.
- `Примеры технологий:` HTTP, FTP, SMTP, DNS, POP3.

___

### Основные принципы модели OSI:

- `Модульность:` Каждый уровень решает определенные задачи и имеет четко определенные интерфейсы с уровнями выше и ниже.
- `Интероперабельность:` Обеспечивает совместимость различных сетевых устройств и программного обеспечения от разных производителей.
- `Стандартизация:` Способствует созданию стандартов, которые упрощают разработку сетевых решений и их внедрение.


### Преимущества модели OSI:

- `Понятность и структурированность: `Модель OSI предоставляет четкое представление о том, как данные перемещаются по сети.
- `Универсальность:` Подходит для различных типов сетей и протоколов.
- `Модульность:` Облегчает разработку и внедрение новых технологий, не требуя изменений на всех уровнях.


### Недостатки модели OSI:

- `Сложность:` Полная реализация всех семи уровней может быть сложной и ресурсозатратной.
Практическое применение: На практике чаще используются гибридные модели, такие как стек протоколов TCP/IP.

**Заключение**

Модель OSI представляет собой мощный инструмент для понимания и разработки сетевых решений. Она обеспечивает структуру и стандарты для взаимодействия различных систем и протоколов, способствуя развитию сетевых технологий и их интероперабельности.


[к оглавлению](#Протокол-передачи-данных)

# Модель TCP IP



[к оглавлению](#Протокол-передачи-данных)

`Модель TCP/IP (Transmission Control Protocol/Internet Protocol)` представляет собой набор сетевых протоколов, используемых для передачи данных через интернет. Она была разработана для создания надежной и масштабируемой сети, которая впоследствии стала основой глобальной сети интернет. Модель TCP/IP состоит из четырёх уровней, каждый из которых отвечает за определённый аспект передачи данных.


## Уровни модели TCP/IP

### `Уровень сетевого доступа (Network Access Layer)`

- `Функции:`
 Определяет физические и канальные характеристики сети.
- Обеспечивает передачу данных по физическим носителям (кабели, радиоволны и т.д.).
- `Протоколы и технологии:` Ethernet, Wi-Fi, PPP (Point-to-Point Protocol).
- `Задачи:` Определение способов кодирования данных, управление доступом к среде передачи, обнаружение и исправление ошибок.


### `Интернет-уровень (Internet Layer)`

- `Функции:`
Управляет логической адресацией и маршрутизацией данных между сетями.
Определяет путь для передачи данных от источника к получателю.

- `Протоколы:`
IP (Internet Protocol): Основной протокол, обеспечивающий передачу пакетов данных между узлами.
ICMP (Internet Control Message Protocol): Используется для передачи диагностических и управляющих сообщений.
ARP (Address Resolution Protocol): Преобразует IP-адреса в физические адреса MAC.

- `Задачи:`
Маршрутизация пакетов, фрагментация и сборка данных, определение маршрута.


### `Транспортный уровень (Transport Layer)`

- `Функции:`
 Обеспечивает надёжную передачу данных между узлами.
- Управляет потоками данных, проверяет целостность данных и управляет сегментацией сообщений.
- `Протоколы:`
- TCP (Transmission Control Protocol): Обеспечивает надёжную и последовательную передачу данных, контроль потока и управление соединениями.
- UDP (User Datagram Protocol): Обеспечивает передачу данных без установления соединения, не гарантирует доставку и порядок следования пакетов.
- `Задачи:` Установление и завершение соединений, контроль потока, проверка целостности данных, повторная передача потерянных пакетов.


### `Прикладной уровень (Application Layer)`

- `Функции:`
- Предоставляет интерфейсы и протоколы для взаимодействия приложений и пользователей с сетью.
- Определяет методы доступа к сетевым услугам и обмена данными между приложениями.
- `Протоколы:`
- HTTP (HyperText Transfer Protocol): Протокол передачи гипертекста, используемый для веб-сайтов.
- FTP (File Transfer Protocol): Протокол передачи файлов.
- SMTP (Simple Mail Transfer Protocol): Протокол передачи электронной почты.
- DNS (Domain Name System): Протокол преобразования доменных имён в IP-адреса.
- `Задачи: `Поддержка взаимодействия между приложениями, предоставление сетевых услуг, управление сессиями связи.

### `Отличия модели TCP/IP от модели OSI`

- `Количество уровней:` Модель OSI имеет семь уровней, в то время как модель TCP/IP включает только четыре уровня.
- `Разделение уровней:` В модели TCP/IP прикладной уровень объединяет функции сеансового, представительского и прикладного уровней модели OSI.
- `Историческое развитие:` Модель TCP/IP разрабатывалась параллельно с интернетом и нацелена на практическое применение, в то время как модель OSI представляет собой более теоретическую структуру.
- `Применение:` Модель TCP/IP широко используется в реальных сетях, включая интернет, тогда как модель OSI чаще применяется для образовательных целей и теоретических исследований.

**Заключение**

Модель TCP/IP является основополагающей для современных сетей и интернета. Она обеспечивает гибкость, масштабируемость и надёжность сетевых соединений, благодаря чему успешно используется в различных областях, от корпоративных сетей до глобальной сети интернет. Разделение функций по уровням модели TCP/IP позволяет эффективно управлять передачей данных, обеспечивая взаимодействие между различными системами и устройствами.


# Разница между моделью TCP IP и моделью OSI

`Модель OSI (Open Systems Interconnection) и модель TCP/IP (Transmission Control Protocol/Internet Protocol)-` это две фундаментальные модели, используемые для стандартизации сетевых протоколов и обеспечения интероперабельности между различными системами. Они имеют много общего, но также и значительные различия.


*Основные различия:*

### 1. Структура и количество уровней:

`Модель OSI:`

Семь уровней:

1. Физический (Physical)
1. Канальный (Data Link)
1. Сетевой (Network)
1. Транспортный (Transport)
1. Сеансовый (Session)
1. Представительский (Presentation)
1. Прикладной (Application)


`Модель TCP/IP:`

Четыре уровня:

1. Сетевой доступ (Network Access/Link)
1. Интернет (Internet)
1. Транспортный (Transport)
1. Прикладной (Application)


### 2. Цель создания:

`Модель OSI:`

- Разработана ISO для стандартизации сетевых взаимодействий и облегчения разработки сетевого оборудования и программного обеспечения.

`Модель TCP/IP:`

- Разработана DARPA (Defense Advanced Research Projects Agency) для разработки устойчивой, стандартизированной и интероперабельной сети, которая позднее стала основой для интернета.

### 3. Подход к уровневой архитектуре:

`Модель OSI:`

- Строго структурирована с четко определенными функциями на каждом уровне. Каждому уровню соответствует отдельный протокол или группа протоколов.

`Модель TCP/IP:`

- Более гибкая и менее формализованная структура. Несколько уровней OSI объединены в более широкие уровни TCP/IP.

### 4. Уровни и их функции:

`Модель OSI:`

1. Физический уровень: Определяет физические характеристики сети.
1. Канальный уровень: Обеспечивает надежную передачу данных по физическому каналу.
1. Сетевой уровень: Управляет маршрутизацией пакетов данных.
1. Транспортный уровень: Обеспечивает надежную передачу данных между узлами.
1. Сеансовый уровень: Управляет сеансами связи между приложениями.
1. Представительский уровень: Преобразует данные в формат, удобный для приложения.
1. Прикладной уровень: Предоставляет интерфейсы для взаимодействия пользователя с приложениями.

`Модель TCP/IP:`

1. Сетевой доступ: Включает функции физического и канального уровней OSI.
1. Интернет: Выполняет функции сетевого уровня OSI. Основной протокол - IP.
1. Транспортный: Обеспечивает надежную передачу данных. Основные протоколы - TCP и UDP.
1. Прикладной: Объединяет функции сеансового, представительского и прикладного уровней OSI. Примеры протоколов - HTTP, FTP, SMTP.

### 5. Примеры протоколов:

`OSI:`

1. Физический: Ethernet, USB
1. Канальный: PPP, Ethernet
1. Сетевой: IP, ICMP
1. Транспортный: TCP, UDP
1. Сеансовый: NetBIOS
1. Представительский: JPEG, MPEG
1. Прикладной: HTTP, FTP, SMTP

`TCP/IP:`

1. Сетевой доступ: Ethernet, Wi-Fi
1. Интернет: IP, ICMP
1. Транспортный: TCP, UDP
1. Прикладной: HTTP, FTP, SMTP, DNS

### 6. Реальная применимость:

`Модель OSI:` Используется в основном в образовательных целях и как теоретическая модель для понимания сетевой архитектуры и разработки новых сетевых технологий.

`Модель TCP/IP:` Более практична и широко используется в реальных сетях, особенно в интернете.

**Заключение:**

Модель OSI предоставляет детализированную структуру для понимания и разработки сетевых протоколов, тогда как модель TCP/IP более гибкая и адаптированная к практическому применению. Обе модели важны для сетевой инженерии и имеют свои уникальные особенности и применения.


[к оглавлению](#Протокол-передачи-данных)


# HTTP

`HTTP (HyperText Transfer Protocol)` — это прикладной протокол для передачи гипертекста, который используется для передачи данных в вебе. Он является основой взаимодействия между клиентом и сервером в интернете, обеспечивая передачу данных и команд управления веб-страницами и ресурсами.


### `Основные компоненты HTTP`

`Клиент и сервер`

- `Клиент:` Обычно это веб-браузер или любое приложение, которое отправляет запросы к серверу.
- `Сервер:` Принимает запросы от клиента, обрабатывает их и возвращает соответствующие ответы.

`Запросы и ответы`

- `Запросы:` Клиент отправляет запросы к серверу с использованием методов HTTP.
- `Ответы:` Сервер обрабатывает запрос и возвращает ответ с необходимыми данными и статусом выполнения.


### Методы HTTP

`GET:` Запрашивает данные с сервера. Данные передаются в URL.

> `Пример:` GET /index.html HTTP/1.1

`POST:` Отправляет данные на сервер для создания или обновления ресурса. Данные передаются в теле запроса.

> `Пример:` POST /submit-form HTTP/1.1

`PUT:` Обновляет ресурс на сервере или создает его, если он не существует. Данные передаются в теле запроса.

> `Пример:` PUT /user/123 HTTP/1.1

`DELETE:` Удаляет указанный ресурс с сервера.

> `Пример:` DELETE /user/123 HTTP/1.1

`HEAD:` Запрашивает метаинформацию о ресурсе, без самого тела ресурса.

> `Пример:` HEAD /index.html HTTP/1.1

`OPTIONS:` Запрашивает поддерживаемые сервером методы для ресурса.

> `Пример:` OPTIONS /index.html HTTP/1.1

`PATCH:` Вносит частичные изменения в ресурс.

> `Пример:` PATCH /user/123 HTTP/1.1


[к оглавлению](#Протокол-передачи-данных)

# Структура HTTP запроса

### HTTP-запрос состоит из трех основных частей:

`Стартовая строка (Request Line)`

Указывает метод запроса, URL и версию протокола.

```

Пример:
 GET /index.html HTTP/1.1
```

`Заголовки (Headers)`

Дополнительная информация о запросе и клиенте.

*Пример:*

```makefile
Host: www.example.com
User-Agent: Mozilla/5.0

```

`Тело (Body)`

Данные, передаваемые с запросом (для методов POST, PUT и PATCH).



___

### Структура HTTP-ответа


HTTP-ответ состоит из трех основных частей:

`Стартовая строка (Status Line)`

Указывает версию протокола, статус-код и статусное сообщение.

```
Пример: 
HTTP/1.1 200 OK
```

`Заголовки (Headers)`

Дополнительная информация о сервере и ответе.

Пример:

```yaml

Content-Type: text/html
Content-Length: 1234
```


`Тело (Body)`

Данные, возвращаемые сервером (HTML, JSON, изображения и т.д.).



### `Статус-коды HTTP`

*Статус-коды делятся на несколько категорий:*
- 1xx (Информационные): Уведомления, что запрос принят и обрабатывается.
- 2xx (Успешные): Уведомления об успешной обработке запроса.
- 200 OK: Запрос успешно обработан.
- 201 Created: Ресурс успешно создан.
- 3xx (Перенаправления): Уведомления о необходимости дополнительных действий.
- 301 Moved Permanently: Ресурс перемещен на новый URL.
- 302 Found: Временное перенаправление.
- 4xx (Ошибки клиента): Ошибки, вызванные неправильными запросами клиента.
- 400 Bad Request: Некорректный запрос.
- 401 Unauthorized: Требуется аутентификация.
- 404 Not Found: Ресурс не найден.
- 5xx (Ошибки сервера): Ошибки, вызванные сбоем сервера.
- 500 Internal Server Error: Внутренняя ошибка сервера.
- 503 Service Unavailable: Сервис временно недоступен.



### `Версии HTTP`


`HTTP/1.0`
- Первая версия HTTP с поддержкой базовых методов.
- Каждый запрос требует нового соединения.

`HTTP/1.1`
- Поддерживает постоянные соединения, что улучшает производительность.
- Дополнительные методы (OPTIONS, PUT, DELETE, TRACE).
- Улучшенная обработка заголовков и управление кэшированием.

`HTTP/2`
- Поддержка мультиплексирования, что позволяет отправлять несколько запросов одновременно по одному соединению.
- Сжатие заголовков для уменьшения накладных расходов.
- Улучшенная производительность и уменьшенная задержка.

`HTTP/3`
- Основан на протоколе QUIC, который работает поверх UDP.
- Улучшенное управление задержками и восстановление после потерь пакетов.
- Повышенная безопасность и производительность.


`Заключение`

HTTP является основным протоколом для передачи данных в интернете, обеспечивая взаимодействие между клиентами и серверами. Он поддерживает широкий набор методов для выполнения различных операций с данными и предоставляет механизмы для обработки запросов и ответов. Развитие версий HTTP направлено на улучшение производительности, безопасности и масштабируемости сетевых взаимодействий.


[к оглавлению](#Протокол-передачи-данных)



# Все версии HTTP

### `HTTP/0.9`

`Дата появления:` 1991 год

`Характеристики:`
- Простейшая версия протокола.
- Только метод GET.
- Нет заголовков, только тело ответа.
- Запросы состояли только из строки URI.

Пример запроса:

```bash

GET /index.html

```
Пример ответа:

```html

<html>
  <body>
    <h1>Привет, мир!</h1>
  </body>
</html>
```


### `HTTP/1.0`

`Дата появления: `1996 год

`Характеристики:`
- Добавлены методы: GET, POST, HEAD.
- Поддержка заголовков.
- Каждое соединение ограничено одним запросом/ответом.

Пример запроса:

```vbnet

GET /index.html HTTP/1.0
Host: www.example.com

```

Пример ответа:

```less

HTTP/1.0 200 OK
Content-Type: text/html

<html>
  <body>
    <h1>Привет, мир!</h1>
  </body>
</html>
```


### `HTTP/1.1`

`Дата появления:` 1997 год

`Характеристики:`
- Поддержка постоянных соединений (keep-alive).
- Добавлены методы: OPTIONS, PUT, DELETE, TRACE.
- Улучшенное управление кэшированием.
- Поддержка chunked transfer encoding для передачи данных частями.


Пример запроса:


```vbnet

GET /index.html HTTP/1.1
Host: www.example.com
Connection: keep-alive
```


Пример ответа:

```less

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 70

<html>
  <body>
    <h1>Привет, мир!</h1>
  </body>
</html>
```



### `HTTP/2`

`Дата появления:` 2015 год

`Характеристики:`

- Поддержка мультиплексирования запросов.
- Сжатие заголовков.
- Приоритет запросов.
- Использование двоичного формата вместо текстового.


Пример запроса:

```http
method = GET
scheme = https
authority = www.example.com
path = /index.html
```



Пример ответа:

```http

status = 200
content-type = text/html
content-length = 70

<html>
  <body>
    <h1>Привет, мир!</h1>
  </body>
</html>
```

### `HTTP/3`

`Дата появления:` Ожидается в 2022 году

`Характеристики:`
- Основан на протоколе QUIC, который работает поверх UDP.
- Улучшенное управление задержками.
- Повышенная производительность и безопасность.

Пример запроса:

```http

method = GET
scheme = https
authority = www.example.com
path = /index.html
```

Пример ответа:

```http

status = 200
content-type = text/html
content-length = 70

<html>
  <body>
    <h1>Привет, мир!</h1>
  </body>
</html>
```



[к оглавлению](#Протокол-передачи-данных)


# Ключевые различия между версиями HTTP

- `HTTP/0.9:` Ограниченные возможности, только метод GET и отсутствие заголовков.
- `HTTP/1.0:` Введение заголовков и новых методов, но каждое соединение ограничено одним запросом.
- `HTTP/1.1:` Поддержка постоянных соединений, новых методов и улучшенное управление кэшированием.
- `HTTP/2:` Мультиплексирование, сжатие заголовков и двоичный формат для улучшенной производительности.
- `HTTP/3:` Основан на QUIC для лучшей производительности и надежности, работает поверх UDP.

**Заключение**

HTTP прошел долгий путь с момента своего создания, каждая новая версия протокола улучшала производительность, безопасность и функциональность. Основные улучшения включали введение заголовков, поддержку постоянных соединений, мультиплексирование запросов и переход на использование двоичного формата и протокола QUIC.


[к оглавлению](#Протокол-передачи-данных)


# HTTPS


`HHTTPS (HyperText Transfer Protocol Secure)` — это протокол для безопасной передачи данных между веб-браузером и веб-сервером. HTTPS использует шифрование для защиты данных от перехвата и вмешательства, обеспечивая конфиденциальность и целостность информации, передаваемой по сети.

## Основные аспекты HTTPS

`Шифрование:`

- HTTPS использует протокол TLS (Transport Layer Security) для шифрования данных. TLS обеспечивает защиту данных от перехвата злоумышленниками.
- Когда устанавливается HTTPS-соединение, браузер и сервер договариваются о ключах шифрования, которые используются для шифрования и дешифрования данных.

`Аутентификация:`

- HTTPS использует цифровые сертификаты для подтверждения подлинности веб-сайта. Цифровой сертификат выдается сертификационным центром (CA, Certificate Authority), который подтверждает, что веб-сайт принадлежит заявленному владельцу.
- Когда браузер устанавливает соединение с веб-сайтом, он проверяет цифровой сертификат сервера. Если сертификат действителен, браузер доверяет серверу и устанавливает защищенное соединение.

`Целостность данных:`

- HTTPS обеспечивает целостность данных, предотвращая их изменение во время передачи. Любое изменение данных, передаваемых по HTTPS, будет обнаружено, и соединение будет закрыто.

## Как работает HTTPS


*Подробное объяснение процесса*

`Инициирование соединения:`
- Браузер отправляет серверу запрос на установление HTTPS-соединения, используя TCP-порт 443.
Client: Initiates a TCP connection to the server on port 443.


`Обмен "Приветствиями" (TLS Handshake):`

- Клиент отправляет "ClientHello" сообщение, содержащее информацию о поддерживаемых версиях TLS, наборах шифров и случайное значение.
Client -> Server: ClientHello


- Сервер отвечает "ServerHello" сообщением, выбирая версию TLS и набор шифров из предложенных клиентом, и отправляет свой сертификат.
Server -> Client: ServerHello + Certificate


`Проверка сертификата:`
- Клиент проверяет сертификат сервера на подлинность, убедившись, что сертификат выдан доверенным CA и не истек.
- Client: Verifies the server's certificate.


`Генерация и обмен сессионными ключами:`
- Клиент генерирует предмастер-секрет (pre-master secret), шифрует его открытым ключом сервера и отправляет серверу.

```plaintext

Client -> Server: Encrypted Pre-Master Secret
```


Сервер расшифровывает предмастер-секрет своим закрытым ключом.
Клиент и сервер независимо друг от друга вычисляют мастер-секрет (master secret) на основе предмастер-секрета и случайных значений из "Hello" сообщений.


`Создание сессионного ключа:`
- Клиент и сервер генерируют симметричные сессионные ключи для шифрования и дешифрования данных сессии.

```plaintext

Client & Server: Generate session keys.
```


`Установление защищенного соединения:`
- Клиент отправляет сообщение "Finished", шифрованное сессионным ключом, чтобы подтвердить успешное установление защищенного канала.

```plaintext

Client -> Server: Finished

```

- Сервер отвечает аналогичным "Finished" сообщением.

```plaintext

Server -> Client: Finished
```


`Передача данных:`
- Все дальнейшие данные передаются по защищенному каналу, шифрованному сессионными ключами.

```plaintext

Client <-> Server: Encrypted data transmission.
```



## Преимущества HTTPS

`Безопасность:`

- Шифрование данных защищает информацию от перехвата и вмешательства.
Аутентификация защищает от атак типа "человек посередине" (MITM), подтверждая подлинность веб-сайта.

`Конфиденциальность:`

- Личные данные пользователей, такие как логины, пароли и платежная информация, защищены при передаче.

`Целостность:`

- Данные, передаваемые по HTTPS, не могут быть изменены без обнаружения.

`SEO и доверие пользователей:`

- Поисковые системы, такие как Google, предпочитают сайты с HTTPS, что может улучшить рейтинг сайта в результатах поиска.
- Пользователи больше доверяют сайтам с HTTPS, зная, что их данные защищены.




## Недостатки HTTPS

`Производительность:`

- Установка HTTPS-соединения требует дополнительных вычислительных ресурсов для шифрования и дешифрования данных, что может слегка замедлить соединение. Однако с современными технологиями и оптимизациями эти задержки минимальны.

`Стоимость:`

- Цифровые сертификаты могут быть платными, особенно если используются сертификаты от известных сертификационных центров. Однако существуют и бесплатные варианты, такие как Let's Encrypt.

`Сложность настройки:`

- Настройка HTTPS-соединения может требовать дополнительных знаний и усилий, особенно в контексте серверного администрирования и управления сертификатами.



## Примеры использования HTTPS


`Интернет-магазины:`

> Защищают данные пользователей, такие как платежная информация и личные данные, при оформлении покупок.

`Социальные сети:`

> Обеспечивают защиту личных сообщений, логинов и другой конфиденциальной информации пользователей.

`Банковские и финансовые сервисы:`

> Защищают данные клиентов при осуществлении финансовых операций.

`Электронная почта и коммуникационные сервисы:`

> Обеспечивают защиту переписки и данных пользователей.


**Заключение**

HTTPS — это ключевая технология для обеспечения безопасности и конфиденциальности в интернете. Он широко используется для защиты данных пользователей и поддержания доверия к веб-сайтам. Переход на HTTPS стал стандартом для большинства современных веб-сайтов, обеспечивая надежную защиту информации и улучшая пользовательский опыт.


[к оглавлению](#Протокол-передачи-данных)


# TLS SSL

`TLS (Transport Layer Security) и его предшественник SSL (Secure Sockets Layer)` — это криптографические протоколы, предназначенные для обеспечения безопасности передачи данных в интернете. Они используются для шифрования данных, аутентификации серверов и клиентов, а также для обеспечения целостности передаваемой информации.

### `Они предоставляют три основные функции:`

- `Приватность (Confidentiality) `— шифрование данных, чтобы они были недоступны для неавторизованных лиц.
- `Целостность (Integrity)` — обеспечение того, что данные не были изменены или повреждены в процессе передачи.
- `Аутентификация (Authentication)` — подтверждение подлинности участвующих сторон в коммуникации.

*TLS/SSL (Transport Layer Security / Secure Sockets Layer) обеспечивает защищенную передачу данных в интернете и предоставляет три основные функции: приватность, целостность и аутентификацию. *

## `Рассмотрим, как каждая из этих функций достигается.`

### `Приватность (Confidentiality)`

Приватность достигается с помощью шифрования данных, что предотвращает несанкционированный доступ к информации.

> `Процесс включает:`
>> `Обмен ключами:`

>>> При установке соединения клиент и сервер используют асимметричное шифрование (например, RSA или ECDHE) для обмена ключами.
В процессе "рукопожатия" (handshake) клиент и сервер договариваются о наборе шифров и генерируют сеансовые ключи.

>> `Сессионные ключи:`

>>> После завершения "рукопожатия" используются симметричные сеансовые ключи для шифрования и дешифрования данных, передаваемых в сессии.
Симметричное шифрование (например, AES) обеспечивает высокую производительность и безопасность.


### `Целостность (Integrity)`

Целостность данных гарантирует, что данные не были изменены или повреждены во время передачи. Это достигается с помощью хеш-функций и алгоритмов контроля целостности:

> `Хеш-функции:`

>> Хеш-функции (например, SHA-256) используются для создания уникальных контрольных сумм (хешей) данных.
>> Контрольная сумма данных передается вместе с самими данными.

> `MAC (Message Authentication Code):`

>> HMAC (Hash-based Message Authentication Code) используется для создания контрольных сумм на основе секретного ключа.

>> Получатель использует тот же секретный ключ для проверки контрольной суммы и удостоверяется, что данные не изменились.

### `Аутентификация (Authentication)`

Аутентификация подтверждает подлинность участников коммуникации, что достигается с помощью цифровых сертификатов:

> `Цифровые сертификаты:`

>> Сервер предъявляет клиенту цифровой сертификат, выданный доверенным центром сертификации (CA).

>> Клиент проверяет подлинность сертификата, используя корневые сертификаты, которые уже установлены в его системе.

> `Двусторонняя аутентификация:`

>> В некоторых случаях и сервер, и клиент могут обмениваться сертификатами для взаимной аутентификации.


Это обеспечивает дополнительный уровень безопасности, так как обе стороны уверены в подлинности друг друга.

___

### Примеры атак и решения


`Атаки типа "Человек посередине" (Man-in-the-Middle, MITM):`

- `Решение:` Использование цифровых сертификатов и проверка их подлинности с помощью CA предотвращает MITM-атаки.

`Атаки на слабые хеш-функции:`
- `Решение:` Использование надежных хеш-функций, таких как SHA-256, вместо устаревших, таких как MD5.

`Переиспользование ключей:`
- `Решение:` Генерация уникальных сеансовых ключей для каждой сессии с использованием протокола Диффи-Хеллмана (Diffie-Hellman) или ECDHE (Elliptic Curve Diffie-Hellman).



## История и развитие

`SSL:`

- SSL 1.0: Никогда не был публично выпущен.
- SSL 2.0: Вышел в 1995 году, но быстро был заменен из-за серьезных уязвимостей.
- SSL 3.0: Вышел в 1996 году и был значительно более безопасным, но тоже имел уязвимости, которые впоследствии привели к разработке TLS.

`TLS:`

```
TLS 1.0: Вышел в 1999 году как улучшенная и более безопасная версия SSL 3.0.
TLS 1.1: Вышел в 2006 году с улучшениями безопасности.
TLS 1.2: Вышел в 2008 году и включал дополнительные криптографические схемы и улучшения безопасности.
TLS 1.3: Вышел в 2018 году с еще большими улучшениями производительности и безопасности, упрощенным процессом рукопожатия и удалением устаревших криптографических алгоритмов.
```

## Версии TLS и их особенности


- `TLS 1.0:`
-Включает улучшения по сравнению с SSL 3.0, но больше не считается безопасным и не рекомендуется к использованию.
- `TLS 1.1:`
-Улучшения безопасности, включая защиту от некоторых атак типа CBC (Cipher Block Chaining).
- `TLS 1.2:`
-Поддержка новых алгоритмов шифрования, таких как AES, и новых механизмов генерации ключей.
- `TLS 1.3:`
-Существенные улучшения производительности и безопасности. Упрощенное рукопожатие с одним раундом обмена ключами и удаление устаревших и небезопасных шифров, таких как RC4.

## Как работают TLS и SSL

**Процесс установления соединения (рукопожатие)**

`Клиентское приветствие (Client Hello):`

- Клиент отправляет серверу сообщение с предложением установить защищенное соединение, указывая поддерживаемые версии протоколов, шифры и сжатие.

`Серверное приветствие (Server Hello):`

- Сервер отвечает, выбирая версию протокола и шифр из предложенных клиентом.

`Обмен сертификатами:`

- Сервер отправляет свой цифровой сертификат, который содержит открытый ключ сервера. Браузер проверяет подлинность сертификата, удостоверившись, что он был выдан доверенным центром сертификации (CA).


`Обмен ключами:`


- Клиент генерирует случайный секретный ключ (pre-master secret), шифрует его с помощью открытого ключа сервера и отправляет серверу. Только сервер может расшифровать это сообщение с помощью своего закрытого ключа.


`Генерация симметричных ключей:`


- Клиент и сервер используют pre-master secret и другие параметры для генерации симметричных ключей, которые будут использоваться для шифрования и дешифрования данных.


`Сообщение о завершении:`


- Клиент и сервер отправляют друг другу сообщения о завершении, сигнализируя о том, что дальнейшие сообщения будут зашифрованы.


`Передача данных:`


- После завершения рукопожатия все данные, передаваемые между клиентом и сервером, шифруются с использованием симметричных ключей, что обеспечивает их конфиденциальность и целостность.

____

### Атаки на TLS/SSL и меры защиты


`Атаки на SSL/TLS:`


- [x] BEAST (Browser Exploit Against SSL/TLS): Атака на уязвимости в CBC шифрах в SSL 3.0 и TLS 1.0.
- [x] POODLE (Padding Oracle On Downgraded Legacy Encryption): Атака на SSL 3.0.
- [x] Heartbleed: Уязвимость в OpenSSL, позволяющая злоумышленникам читать память сервера.
- [x] FREAK (Factoring RSA Export Keys): Атака, использующая слабые экспортные ключи RSA.
- [x] Logjam: Атака на уязвимые параметры обмена ключами DH (Diffie-Hellman).


`Меры защиты:`

- [x] Отключение устаревших версий протоколов (SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.1).
- [x] Использование только современных и безопасных шифров.
- [x] Регулярное обновление программного обеспечения и библиотек, таких как OpenSSL.
- [x] Использование длинных и надежных ключей для шифрования.


**Заключение**

TLS и SSL играют ключевую роль в обеспечении безопасности и конфиденциальности передачи данных в интернете. Переход на современные версии протоколов, такие как TLS 1.3, и использование надежных алгоритмов шифрования являются важными шагами для защиты данных от перехвата и атак.

[к оглавлению](#Протокол-передачи-данных)


# Установка соединения TLS

Установка соединения TLS (Transport Layer Security) включает несколько этапов и обменов сообщениями между клиентом и сервером. Этот процесс можно разделить на несколько фаз:

`1. Клиентское приветствие (Client Hello)`

** Клиент отправляет сообщение "Client Hello", которое включает:**
- Версию протокола TLS, которую поддерживает клиент.
- Список поддерживаемых криптографических алгоритмов (cipher suites).
- Случайное значение (random nonce), которое используется в процессе создания ключей.
- Дополнительные параметры, такие как сжатие данных и расширения.

`2. Серверное приветствие (Server Hello)`

**Сервер отвечает сообщением "Server Hello", которое содержит:**
- Версию протокола TLS, которую выбрал сервер.
- Выбранный криптографический алгоритм из списка, предложенного клиентом.
- Случайное значение (random nonce) сервера.
- Сертификат сервера (Certificate), подтверждающий подлинность сервера.
- (Опционально) Сообщение "Server Key Exchange", если используется Diffie-Hellman или ECDHE.
- Сообщение "Server Hello Done", сигнализирующее конец серверного приветствия.

`3. Обмен ключами и завершение установки`

- `Client Key Exchange:` Клиент отправляет сообщение "Client Key Exchange". Если используется RSA, то это зашифрованный сессионный ключ. Если используется Diffie-Hellman, то это клиентская часть ключа.
- `Change Cipher Spec (Client):` Клиент отправляет сообщение "Change Cipher Spec", сигнализируя о начале использования согласованных параметров шифрования.
- `Client Finished:` Клиент отправляет сообщение "Finished", зашифрованное сессионным ключом, содержащее хэш всех предыдущих сообщений (для проверки целостности и аутентичности).
- `Change Cipher Spec (Server):` Сервер отправляет сообщение "Change Cipher Spec", сигнализируя о начале использования согласованных параметров шифрования.
- `Server Finished:` Сервер отправляет сообщение "Finished", зашифрованное сессионным ключом, содержащее хэш всех предыдущих сообщений.


### Схема установки TLS-соединения

```plaintext


Client                              Server
  |                                    |
  | ------ Client Hello ------------>  |
  |                                    |
  | <------- Server Hello ------------ |
  | <------ Certificate -------------- |
  | <------ Server Key Exchange ------ | (if applicable)
  | <------ Server Hello Done -------- |
  |                                    |
  | ------ Client Key Exchange ------> |
  | ------ Change Cipher Spec ------>  |
  | ------ Finished ---------------->  |
  |                                    |
  | <------ Change Cipher Spec ------- |
  | <------ Finished ----------------- |
  |                                    |
  |          Encrypted Data            |
  | <------ Encrypted Data ----------> |


```

### Подробное описание сообщений

`Client Hello:`
- Версия TLS (например, TLS 1.2, 1.3).
- Случайное значение (random).
- Идентификатор сессии (если есть).
- Список поддерживаемых наборов шифров (cipher suites).
- Список поддерживаемых методов сжатия (compression methods).
- Дополнительные расширения (например, поддержка SNI, ALPN).

`Server Hello:`

- Версия TLS.
- Случайное значение (random).
- Идентификатор сессии (если есть).
- Выбранный набор шифров.
- Выбранный метод сжатия.
- Дополнительные расширения (если применимо).

`Certificate:`
- Сертификат сервера или цепочка сертификатов, заверяющая подлинность сервера.
- Server Key Exchange (если требуется):
- Параметры для создания общего ключа (в случае Diffie-Hellman или ECDHE).
- Client Key Exchange:
- Зашифрованный сессионный ключ (в случае RSA) или клиентская часть ключа (в случае Diffie-Hellman или ECDHE).

`Change Cipher Spec:`

- Однобайтовое сообщение, сигнализирующее о начале использования согласованных параметров шифрования.

`Finished:`

- Сообщение, зашифрованное сессионным ключом, содержащее хэш всех предыдущих сообщений (для проверки целостности и аутентичности).
- После этого обмена данные передаются в зашифрованном виде, используя согласованные параметры шифрования.

___

### Наборы шифров (cipher suites) в протоколе TLS определяют набор криптографических алгоритмов, используемых для шифрования соединения. 

### Они включают алгоритмы для:

- Ключевого обмена: Определяет, как клиент и сервер договариваются о совместном ключе.
- Аутентификации: Определяет, как клиент и сервер аутентифицируют друг друга.
- Шифрования: Определяет, как данные шифруются.
- Хеширования: Используется для создания HMAC (Hash-based Message Authentication Code) для обеспечения целостности и подлинности сообщений.

### Компоненты набора шифров

**Ключевой обмен (Key Exchange)**

- RSA: Клиент шифрует секретный ключ, используя открытый ключ сервера. Сервер расшифровывает его своим закрытым ключом.
- DHE: Диффи-Хеллман с временными ключами, обеспечивающий прямую конфиденциальность.
- ECDHE: Эллиптическая кривая Диффи-Хеллман с временными ключами, обеспечивающий прямую конфиденциальность.

`Аутентификация (Authentication)`

- RSA: Сертификат сервера содержит RSA-ключ.
- ECDSA: Сертификат сервера содержит ключ ECDSA.

`Шифрование (Encryption)`

- AES: Advanced Encryption Standard с ключами разной длины (128 или 256 бит).
- ChaCha20: Быстрая и безопасная замена AES.

`Хеширование (Hashing)`

- SHA-1: Старый стандарт, ныне считающийся небезопасным.
- SHA-256 и SHA-384: Современные стандарты, обеспечивающие лучшую безопасность.

### Пример использования набора шифров

- При установке TLS-соединения клиент отправляет серверу список поддерживаемых наборов шифров. Сервер выбирает наиболее безопасный и поддерживаемый набор из списка и отвечает клиенту с выбранным набором.

### Обновления и изменения в TLS 1.3

TLS 1.3 упростил использование наборов шифров, исключив многие устаревшие и небезопасные алгоритмы. Например, в TLS 1.3 нет разделения на ключевой обмен и аутентификацию, вместо этого используется понятие "шифровальных пакетов" (cipher suites), которые включают только шифрование и хеширование. Ключевой обмен и аутентификация теперь определяются отдельно.

### Примеры наборов шифров в TLS 1.3:

- TLS_AES_128_GCM_SHA256
- TLS_AES_256_GCM_SHA384
- TLS_CHACHA20_POLY1305_SHA256

### Выбор безопасных наборов шифров

Для обеспечения безопасности рекомендуется использовать современные и проверенные наборы шифров, такие как:

- TLS_AES_128_GCM_SHA256
- TLS_AES_256_GCM_SHA384
- TLS_CHACHA20_POLY1305_SHA256

Эти наборы обеспечивают высокую производительность и надежную защиту данных.


[к оглавлению](#Протокол-передачи-данных)